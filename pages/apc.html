<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>APC</title>
  <link rel="stylesheet" href="../styles/base.css">
</head>
<body>

<script type="module">
/* =========================================================
   MODULE IMPORTS
   ========================================================= */

import { loadLayout } from "../app/layout.js";
import { servers } from "../data/servers.js";
import { appState, setSlot } from "../app/state.js";
import {
  calculateSlot,
  calculateBanks,
  calculatePhases,
  
  usagePercent
} from "../core/calculator.js";

/* =========================================================
   CONFIGURATION
   ========================================================= */

/**
 * Allowed utilization presets for servers.
 * These map to power draw multipliers in the calculator.
 */
const UTIL = ["low", "normal", "high", "max"];

/**
 * Default utilization when placing or resetting servers.
 */
const DEFAULT_UTIL = "normal";


// === APC CONFIG ===

// 2 banks: Top (8), Bottom (16)
const BANK_LABELS = ["Top", "Bottom"];
const BANK_SLOTS  = [8, 16];
const TOTAL_SLOTS = 44;

// 1 phase only
const PHASE_COUNT  = 1;
const PHASE_LABELS = ["L1"];

// Limits 
const LIMITS = {
  bank: 8,   // 16A / bank
  phase: 16   // 32A totaal
};

const BANK_ROWSPAN = [
  16, // Top bank (1–16)
  TOTAL_SLOTS - 16 // Bottom bank (17–48)
];


const PHASE_ROWSPAN = TOTAL_SLOTS + 1;



const RACK_U_SLOTS = [
  7, 9, 11, 13, 15, 17, 19, 21,   
  23, 25, 27, 29, 31, 33, 35, 37,
  39, 41, 43,
];

let rackMeta = {
  dc: null,
  sr: null,
  rk: null
};



/* =========================================================
   APC CONFIGURATION
   ========================================================= */

const TOTAL_RACK_SLOTS = 44;

/**
 * Rack → PDU mapping
 * Slots without entry have no PDU slot
 */
const APC_RACK_TO_PDU = {
  1:  1,
  3:  2,
  5:  3,
  7:  4,
  9:  5,
  11: 6,
  13: 7,
  15: 8,
  17: 11,
  19: 12,
  21: 13,
  //Switchstack
  23: 14,
  25: 15,
  27: 16,
  29: 17,
  31: 18,
  33: 19,
  35: 20,
  37: 21,
  39: 22,
  41: 23,
  43: 24
};

/**
 * Bank limits
 */
const BANK_LIMITS = {
  Top: 8,
  Bottom: 8
};

const PHASE_LIMIT = 16; // L1

/* =========================================================
   UI HELPERS
   ========================================================= */

/**
 * Shows a temporary warning bubble on the Server column
 * for a given rack slot (e.g. invalid 2U placement).
 */
function showFloatingWarning(slot, message) {
  const row = document.querySelector(`tr[data-slot="${slot}"]`);
  if (!row) return;

  const cell = row.children[2]; // Server column

  cell.classList.remove("slot-warning");
  const old = cell.querySelector(".slot-warning-bubble");
  if (old) old.remove();

  cell.classList.add("slot-warning");

  const bubble = document.createElement("div");
  bubble.className = "slot-warning-bubble";
  bubble.textContent = message;

  cell.style.position = "relative";
  cell.appendChild(bubble);

  setTimeout(() => {
    cell.classList.remove("slot-warning");
    bubble.remove();
  }, 3000);
}





/* =========================================================
   APC PDU HELPERS
   ========================================================= */

function getBankIndex(rackSlot) {
  // Top bank
  if (rackSlot >= 1 && rackSlot <= 16) return 0;

  // Bottom bank
  if (rackSlot >= 17 && rackSlot <= 44) return 1;

  return null;
}

function getBankRowspan(bankIndex) {
  return bankIndex === 0 ? 16 : 28; // 17–44 = 28 slots
}

function isBankStart(rackSlot) {
  return rackSlot === 1 || rackSlot === 17;
}

function isPhaseStartSlot(slot) {
  return slot === 1;
}

function getPhaseRowspan() {
  return TOTAL_SLOTS;
}

function getPDUSlotForRack(rackSlot) {
  if (rackSlot % 2 === 0) return "-";
  const index = (rackSlot + 1) / 2;
  return index <= 24 ? index : "-";
}

function getPDUSlot(rackSlot) {
  return APC_RACK_TO_PDU[rackSlot] ?? null;
}



/* =========================================================
   COLOR & VISUAL HELPERS
   ========================================================= */

/**
 * Returns a color gradient from green → orange → red
 * based on a normalized load value (0.0 – 1.0).
 *
 * Used for bank and phase load visualization.
 */
function gradient(p) {
  p = Math.max(0, Math.min(1, p));

  const green  = { r: 9,   g: 156, b: 28  };
  const warn   = { r: 243, g: 156, b: 18  };
  const danger = { r: 231, g: 76,  b: 60  };

  let from, to, t;

  if (p < 0.8) {
    from = green;
    to   = warn;
    t    = p / 0.8;
  } else {
    from = warn;
    to   = danger;
    t    = (p - 0.8) / 0.2;
  }

  return `rgb(
    ${Math.round(from.r + (to.r - from.r) * t)},
    ${Math.round(from.g + (to.g - from.g) * t)},
    ${Math.round(from.b + (to.b - from.b) * t)}
  )`;
}

/* =========================================================
   U-HEIGHT & SLOT PLACEMENT HELPERS
   ========================================================= */

/**
 * Attempts to detect server height (U) from a CSV line.
 * Supports formats like: "1U", "2U", "U4".
 *
 * @param {string} line - Raw CSV line
 * @param {number} fallback - Default U height if none detected
 */
function detectUHeightFromCSV(line, fallback = 1) {
  const l = line.toLowerCase();

  const match1 = l.match(/(?:^|\D)([124])u(?:\D|$)/);
  if (match1) return Number(match1[1]);

  const match2 = l.match(/u([124])/);
  if (match2) return Number(match2[1]);

  return fallback;
}

/**
 * Validates whether a server of given U height
 * can be placed at the specified rack slot.
 *
 * Rules enforced:
 * - All required slots must be empty
 * - Multi-U servers cannot overlap other servers
 * - Placement must stay within the same bank
 * - Placement must stay within the same phase
 */
function fitsUHeight(startSlot, uHeight) {

  // Check that required slots are free
  for (let i = 0; i < uHeight; i++) {
    const slot = startSlot + i;
    if (slot > TOTAL_SLOTS) return false;
    if (appState.slots[slot].serverId) return false;
    if (appState.slots[slot].occupiedBy) return false;
  }

  // For multi-U servers, slot directly below must be free
  if (uHeight > 1) {
    const below = startSlot + 1;
    if (
      below <= TOTAL_SLOTS &&
      (
        appState.slots[below]?.serverId ||
        appState.slots[below]?.occupiedBy
      )
    ) {
      return false;
    }
  }

  // Bank and phase must remain consistent
  const bank  = getBankIndex(startSlot);
 

  for (let i = 1; i < uHeight; i++) {
    const s = startSlot + i;
    if (getBankIndex(s) !== bank) return false;
  }

  return true;
}

/**
 * Marks additional slots as occupied by a multi-U server.
 */
function blockSlots(startSlot, uHeight) {
  for (let i = 1; i < uHeight; i++) {
    setSlot(startSlot + i, "occupiedBy", startSlot);
  }
}

/**
 * Clears occupied slots belonging to a given starting slot.
 * Used when removing or relocating servers.
 */
function clearBlockedSlots(startSlot) {
  for (let i = 1; i <= TOTAL_SLOTS; i++) {
    if (appState.slots[i].occupiedBy === startSlot) {
      setSlot(i, "occupiedBy", null);
    }
  }
}

/* =========================================================
   CSV IMPORT HELPER
   ========================================================= */

function detectSLtag(text) {
  if (!text) return null;

  const match = text.match(/\b((?:SL01|LS)[A-Z0-9_-]*)\b/i);
  return match ? match[1].toUpperCase() : null;
}

function detectLink(text) {
  const match = text.match(/https?:\/\/[^\s"]+/i);
  return match ? match[0] : null;
}

function detectGeneration(text) {
  const match = text.match(/\bV(\d)\b/i);
  return match ? `v${match[1]}` : null;
}



/* =========================================================
   CSV IMPORT (BLOCK-BASED RACK PARSING)
   ========================================================= */

/**
 * Imports a CSV file exported from IMS and places servers
 * into the rack based on detected slot blocks.
 *
 * The importer works block-based:
 * - A new block starts when a line contains "slXX"
 * - All following lines belong to that slot until a new one starts
 * - Rack ID is auto-detected from "<rack>.sr" (e.g. ams03.sr, fra02.sr)
 */
function importCSV(file) {
  const reader = new FileReader();

  reader.onload = e => {
    const lines = e.target.result.split(/\r?\n/);

    console.group("CSV IMPORT (block based)");
    console.log("Total raw lines:", lines.length);

    const blocks = [];
    let current = null;
    let detectedRackId = null;

    /* =========================================================
       HELPERS
       ========================================================= */

    function normalize(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, "");
    }

    function detectGeneration(text) {
      // alleen expliciete V3, niets anders forceren
      const m = text.match(/[-_\s]v(3)\b/i);
      return m ? `v${m[1]}` : null;
    }

    function placeUnknown(slot, rawText, sltag, link) {
      setSlot(slot, "serverId", "__UNKNOWN__");
      setSlot(slot, "utilization", null);
      setSlot(slot, "unknownLabel", rawText.trim());
      setSlot(slot, "sltag", sltag);
      setSlot(slot, "sltagLink", link);
    }

    /* =========================================================
       BUILD SLOT BLOCKS
       ========================================================= */

    for (const line of lines) {
      if (!line.trim()) continue;

      const lower = line.toLowerCase();
      const slotMatch = lower.match(/sl(\d{1,2})/);

      if (slotMatch) {
        if (current) blocks.push(current);

        current = {
          slot: Number(slotMatch[1]),
          text: line
        };
      } else if (current) {
        current.text += " " + line;
      }
    }

    if (current) blocks.push(current);

    console.log("Total blocks detected:", blocks.length);

    /* =========================================================
       PROCESS BLOCKS
       ========================================================= */

    for (const block of blocks) {
      console.groupCollapsed(`BLOCK slot ${block.slot}`);

      const rawText = block.text;
      const lower   = rawText.toLowerCase();
      const normTxt = normalize(rawText);
      const slot    = block.slot;

      console.log("block text:", rawText);

      /* ---- SL tag & link ---- */
      const sltag = detectSLtag(rawText);
      const link  = detectLink(rawText);

      /* ---- rack-id ---- */
const rackMatch = lower.match(/([a-z0-9]+)\.sr(\d+)\.rk(\d+)/);

if (!rackMatch) {
  console.log("⏭ skipped: no rack id");
  console.groupEnd();
  continue;
}

rackMeta.dc = rackMatch[1].toUpperCase();
rackMeta.sr = "SR" + rackMatch[2];
rackMeta.rk = "RK" + rackMatch[3];

      const rackId = rackMatch[1];
      if (!detectedRackId) detectedRackId = rackId;
      if (rackId !== detectedRackId) {
        console.log("⏭ skipped: other rack");
        console.groupEnd();
        continue;
      }

      /* ---- slot range ---- */
      if (slot < 1 || slot > TOTAL_SLOTS) {
        console.log("❌ slot out of range:", slot);
        console.groupEnd();
        continue;
      }

      /* =====================================================
         MODEL RESOLUTION
         ===================================================== */

      const generation = detectGeneration(rawText);
      const uHeight = detectUHeightFromCSV(rawText, 1);

      console.log("detected generation:", generation);
      console.log("detected uHeight:", uHeight);

      let baseCandidates = servers.filter(s =>
        !s.blocked && 
        s.baseId &&
        normTxt.includes(normalize(s.baseId))
      );

      console.log(
        "base candidates:",
        baseCandidates.map(s => s.id)
      );

      if (!baseCandidates.length) {
        console.warn("⚠ UNKNOWN (no baseId match)");
        placeUnknown(slot, rawText, sltag, link);
        console.groupEnd();
        continue;
      }

      if (generation) {
        const genFiltered = baseCandidates.filter(
          s => s.generation === generation
        );

        if (genFiltered.length) {
          baseCandidates = genFiltered;
        } else {
          console.warn("⚠ generation specified but no match:", generation);
        }
      }

      const server =
        baseCandidates.find(s => s.uHeight === uHeight) ||
        baseCandidates.find(s => s.uHeight == null) ||
        baseCandidates[0];

      if (!server) {
        console.warn("⚠ UNKNOWN (no resolved server)");
        placeUnknown(slot, rawText, sltag, link);
        console.groupEnd();
        continue;
      }

      /* =====================================================
         PLACE SERVER
         ===================================================== */

      clearBlockedSlots(slot);

      setSlot(slot, "serverId", server.id);
      setSlot(slot, "utilization", DEFAULT_UTIL);
      setSlot(slot, "unknownLabel", null);
      setSlot(slot, "sltag", sltag);
      setSlot(slot, "sltagLink", link);

      blockSlots(slot, server.uHeight ?? uHeight);

      console.log("✅ placed:", server.id);
      console.groupEnd();
    }

    console.groupEnd();
    render();
  };

  reader.readAsText(file);
}


/* =========================================================
   HELPERS
   ========================================================= */
  
function getExtraPSURows(server) {
  if (!server) return 0;
  const feeds = Math.ceil(server.psuCount / 2);
  return Math.max(0, feeds - 1);
}

function findServerStartSlot(slot) {
  for (let i = slot; i >= 1; i--) {
    const s = appState.slots[i];
    if (!s) return null;
    if (s.serverId) return i;
  }
  return null;
}

function isPSUFeedSlot(slot) {
  const self = appState.slots[slot];

  if (self?.serverId) return false;

  const startSlot = findServerStartSlot(slot - 1);
  if (!startSlot) return false;

  const parent = appState.slots[startSlot];
  if (!parent?.serverId || parent.serverId === "__UNKNOWN__") return false;

  const server = servers.find(s => s.id === parent.serverId);
  if (!server) return false;

  const feeds = Math.ceil(server.psuCount / 2);
  const extraRows = feeds - 1;

  return extraRows > 0 &&
         slot > startSlot &&
         slot <= startSlot + extraRows;
}



/* =========================================================
   RENDER
   ========================================================= */

function render() {

  /* ---- slot calculations ---- */

  const slotResults = {};

  for (let i = 1; i <= TOTAL_SLOTS; i++) {
    const s = appState.slots[i];
    if (!s.utilization) s.utilization = DEFAULT_UTIL;

    const server =
      s.serverId === "__UNKNOWN__"
        ? null
        : servers.find(x => x.id === s.serverId);

    slotResults[i] = server
      ? calculateSlot(server, s.utilization)
      : null;
  }

  /* ---- bank & phase totals ---- */

  const banks  = [0, 0];
  const phases = [0];

for (let i = 1; i <= TOTAL_SLOTS; i++) {
  const s = appState.slots[i];
  if (!s?.serverId || s.serverId === "__UNKNOWN__") continue;

  const server = servers.find(x => x.id === s.serverId);
  const calc = slotResults[i];
  if (!server || !calc) continue;

  const feeds = Math.ceil(server.psuCount / 2); // 1 PSU = 1, 2 PSU = 1, 4 PSU = 2

  const bankIndex = getBankIndex(i);

  if (bankIndex !== null) {
    banks[bankIndex] += calc.ampsPerFeed * feeds;
  }

  phases[0] += calc.ampsPerFeed * feeds;
}


  /* ---- build rows ---- */

  let rows = "";

  for (let i = 1; i <= TOTAL_SLOTS; i++) {
    
    if (isPSUFeedSlot(i)) {
  const parentSlot = findServerStartSlot(i - 1);
  const parent = appState.slots[parentSlot];
  const server = servers.find(s => s.id === parent.serverId);
  const calc   = slotResults[parentSlot];

  if (!server || !calc) continue;

  rows += `
    <tr class="psu-row">
      <td>${getPDUSlot(i) ?? "-"}</td>
      <td>${i}</td>
      <td></td>
      <td><span class="psu-feed">PSU</span></td>
      <td>—</td>
      <td>${server.psuCount}</td>
      <td>${server.psuWatts}</td>
      <td>${server.voltage}</td>
      <td>—</td>
      <td>${calc.ampsPerFeed.toFixed(2)}</td>
    </tr>
  `;
  continue;
}



    if (i === 23) {
      rows += `
        <tr class="stack-separator">
          <td colspan="10" class="stack-label">SWITCH STACK</td>
        </tr>
      `;
    }

    const s = appState.slots[i];
    const server =
      s.serverId === "__UNKNOWN__"
        ? null
        : servers.find(x => x.id === s.serverId);

    const calc = slotResults[i];

    const bankIndex  = getBankIndex(i);
    const bankStart  = isBankStart(i);
    const phaseStart = isPhaseStartSlot(i);
    const bankExtraRow =
          bankIndex === 1 ? 1 : 0; // alleen bottom bank


    const rowClass =
      s.placedBy === "suggest" ? "placed-suggest" :
      s.occupiedBy ? "occupied-slot" : "";

    rows += `
      <tr data-slot="${i}" class="${rowClass}">

        <td>${getPDUSlot(i) ?? "-"}</td>
        <td>${i}</td>

        <td>
  ${
    s.sltag
      ? s.sltagLink
        ? `<a href="${s.sltagLink}"
             target="_blank"
             rel="noopener noreferrer"
             class="sltag-link">
             ${s.sltag}
           </a>`
        : s.sltag
      : "-"
  }
</td>

        <td>
          ${s.occupiedBy ? "—" :
            s.serverId === "__UNKNOWN__"
              ? `<em>Unknown (import)</em>`
              : `
                <select data-slot="${i}" data-key="serverId">
                  <option value="">-</option>
                  ${servers.map(x =>
                    `<option value="${x.id}" 
                    ${s.serverId===x.id?"selected":""}
                    ${x.blocked ? "disabled" : ""}>
                    ${x.name}
                    
                    </option>`
                    
                  ).join("")}
                </select>`
          }
        </td>

        <td>
          ${s.occupiedBy || s.serverId==="__UNKNOWN__" ? "—" : `
            <select data-slot="${i}" data-key="utilization">
              ${UTIL.map(u =>
                `<option value="${u}" ${s.utilization===u?"selected":""}>${u}</option>`
              ).join("")}
            </select>`
          }
        </td>

        <td>${server?.psuCount ?? "-"}</td>
        <td>${server?.psuWatts ?? "-"}</td>
        <td>${server?.voltage ?? "-"}</td>
        <td>${calc?.totalAmps?.toFixed(2) ?? "-"}</td>
        <td>${calc?.ampsPerFeed?.toFixed(2) ?? "-"}</td>



${bankStart ? `
  <td rowspan="${getBankRowspan(bankIndex) + bankExtraRow}">
    ${BANK_LABELS[bankIndex]}
  </td>
  <td rowspan="${getBankRowspan(bankIndex) + bankExtraRow}"
      style="background:${gradient(
        usagePercent(banks[bankIndex], LIMITS.bank)
      )}">
    ${banks[bankIndex].toFixed(2)} / ${LIMITS.bank}A
  </td>
` : ``}





        ${phaseStart ? `
          <td rowspan="${getPhaseRowspan() + 1}">L1</td>
          <td rowspan="${getPhaseRowspan() + 1}"
              style="background:${gradient(
                usagePercent(phases[0], LIMITS.phase)
              )}">
            ${phases[0].toFixed(2)} / ${LIMITS.phase}A
          </td>
        ` : ``}

      </tr>
    `;
  }



  /* -------------------------
     INJECT HTML
     ------------------------- */
const rackInfoBox = `
  <div class="rack-meta">
    ${
      rackMeta.dc
        ? `${rackMeta.dc} – ${rackMeta.sr} – ${rackMeta.rk}`
        : `DC: __ - SR: __ - RK: __`
    }
  </div>
`;



document.getElementById("content").innerHTML = `
  
  <div class="load-groups">
      <div class="load-group">
        <div class="load-summary">${bankBoxes(banks)}</div>
      </div>
      <div class="load-group">
        <div class="load-summary">${phaseBoxes(phases)}</div>
      </div>
  </div>

<div class="top-bar">

  <div class="rack-meta">
    ${
      rackMeta.dc
        ? `${rackMeta.dc} – ${rackMeta.sr} – ${rackMeta.rk}`
        : `DC: __ – SR: __ – RK: __`
    }
  </div>

  <div class="action-bar">

    <select id="suggestServer">
      <option value="">– select server –</option>
      ${servers.map(s => `<option value="${s.id}">${s.name}</option>`).join("")}
    </select>

    <button id="suggestSlot">Suggest</button>

    <div class="tooltip-wrapper">
      <button id="importRack">Import CSV</button>
      <div class="tooltip">
        <strong>How to use CSV Import</strong><br><br>
        1. Go to IMS Hardware Search<br>
        2. Select Datacenter, Room and Rack<br>
        3. Select Web server as hardware function<br>
        4. Export as CSV<br><br>
        Import the CSV file unchanged.
      </div>
    </div>

    <div class="tooltip-wrapper">
      <button id="resetServers">Reset Servers</button>
      <div class="tooltip">
        Removes all servers from the rack layout.
      </div>
    </div>

    <div class="tooltip-wrapper">
      <button id="resetUtil">Reset Utilization</button>
      <div class="tooltip">
        Resets utilization of all servers to normal.
      </div>
    </div>

    <input type="file" id="importFile" accept=".csv" hidden>

  </div>

</div>


    <table>
      <thead>
        <tr>
          <th>PDU Slot</th><th>Rack Slot</th><th>SLtag</th><th>Server</th><th>Utilization</th>
          <th>PSU</th><th>Watts</th><th>Volt</th>
          <th>Total Amp</th><th>Amp / feed</th>
          <th>Bank</th><th>Bank Load</th>
          <th>Phase</th><th>Phase Load</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `;

  bindUIActions(banks, phases);
}




/* =========================================================
   UI ACTION BINDINGS
   ========================================================= */

function bindUIActions(banks, phases) {

  /* ---------- SUGGEST SLOT ---------- */
  const suggestBtn = document.getElementById("suggestSlot");
  if (suggestBtn) {
    suggestBtn.onclick = () => {
      const serverId = document.getElementById("suggestServer")?.value;
      if (!serverId) {
        alert("Select a server first");
        return;
      }

      const r = suggestBestSlot(serverId, banks, phases);
      if (!r) {
        alert("No suitable slot found");
        return;
      }

      if (!fitsUHeight(r.slot, r.uHeight)) {
        showFloatingWarning(r.slot, "Slot below is occupied");
        return;
      }

      if (confirm(`Best slot: ${r.slot} (${r.uHeight}U)\n\nPlace in rack?`)) {
        clearBlockedSlots(r.slot);
        setSlot(r.slot, "serverId", serverId);
        setSlot(r.slot, "utilization", DEFAULT_UTIL);
        setSlot(r.slot, "placedBy", "suggest");
        blockSlots(r.slot, r.uHeight);
        render();
      }
    };
  }

  /* ---------- IMPORT CSV ---------- */
  const importBtn = document.getElementById("importRack");
  const importFile = document.getElementById("importFile");

  if (importBtn && importFile) {
    importBtn.onclick = () => importFile.click();

    importFile.onchange = e => {
      if (e.target.files.length) {
        importCSV(e.target.files[0]);
      }
      e.target.value = "";
    };
  }

  /* ---------- RESET BUTTONS ---------- */
  const resetServersBtn = document.getElementById("resetServers");
  if (resetServersBtn) {
    resetServersBtn.onclick = () => resetServers();
  }

  const resetUtilBtn = document.getElementById("resetUtil");
  if (resetUtilBtn) {
    resetUtilBtn.onclick = () => resetUtilization();
  }

  /* ---------- SLOT DROPDOWNS ---------- */
  document.querySelectorAll("select[data-slot]").forEach(sel => {
    sel.onchange = () => {
      const slot = +sel.dataset.slot;
      const key  = sel.dataset.key;
      const val  = sel.value || null;

      /* UTILIZATION */
      if (key === "utilization") {
        setSlot(slot, "utilization", val);
        render();
        return;
      }

      /* SERVER */
      if (key === "serverId") {
        const server = servers.find(s => s.id === val);
        const uHeight = server?.uHeight ?? 1;

        if (server && !fitsUHeight(slot, uHeight)) {
          showFloatingWarning(slot, "Slot below is occupied");
          sel.value = "";
          return;
        }

        clearBlockedSlots(slot);
        setSlot(slot, "serverId", val);

        if (server) {
          blockSlots(slot, uHeight);
        }

        render();
      }
    };
  });
}

/* =========================================================
   ACTIONS
   ========================================================= */

/**
 * Removes all servers from the rack.
 * Clears placement, blocking, and unknown import labels.
 * Triggers a full UI re-render.
 */
function resetServers() {
  for (let i = 1; i <= TOTAL_SLOTS; i++) {
    setSlot(i, "serverId", null);
    setSlot(i, "utilization", DEFAULT_UTIL); // of null als je dat wilt
    setSlot(i, "sltag", null);
    setSlot(i, "placedBy", null);
    setSlot(i, "occupiedBy", null);
    setSlot(i, "unknownLabel", null);
  }
  render();
}

/**
 * Resets utilization level of all slots
 * back to the default utilization preset.
 * Triggers a full UI re-render.
 */
function resetUtilization() {
  for (let i = 1; i <= TOTAL_SLOTS; i++) {
    setSlot(i, "utilization", DEFAULT_UTIL);
  }
  render();
}

/* =========================================================
   LOAD SUMMARY CARDS (BANKS / PHASES)
   ========================================================= */

/**
 * Renders a single load status card.
 * Color and status are derived from utilization percentage.
 */
function statusBox(label, value, limit) {
  const pct = value / limit;

  let cls = "ok";
  let text = "OK";

  if (pct >= 1) {
    cls = "bad";
    text = "OVERLOAD";
  } else if (pct >= 0.8) {
    cls = "warn";
    text = "WARNING";
  }

  return `
    <div class="load-box ${cls}">
      <div class="load-title">${label}</div>
      <div class="load-value">${value.toFixed(2)} A</div>
      <div class="load-status">${text}</div>
    </div>
  `;
}

/**
 * Builds load summary cards for all banks.
 */
const bankBoxes = banks =>
  BANK_SLOTS.map((_, i) =>
    statusBox(
      `Bank ${(i % 2) + 1}`,
      banks[i] ?? 0,
      LIMITS.bank
    )
  ).join("");

/**
 * Builds load summary cards for all phases.
 */
const phaseBoxes = phases =>
  Array.from({ length: PHASE_COUNT }, (_, i) =>
    statusBox(
      `Phase L${i + 1}`,
      phases[i] ?? 0,
      LIMITS.phase
    )
  ).join("");

/* =========================================================
   SLOT SUGGESTION LOGIC
   ========================================================= */

/**
 * Determines the best available rack slot for a given server,
 * based on bank and phase load balancing.
 *
 * Returns the optimal slot object or null if no safe slot exists.
 */
function suggestBestSlot(serverId, banks, phases) {
  const server = servers.find(s => s.id === serverId);
  if (!server) return null;

  const uHeight = server.uHeight ?? 1;
  const ampsPerFeed =
    calculateSlot(server, DEFAULT_UTIL)?.ampsPerFeed ?? 0;

  let best = null;

for (let slot = 1; slot <= TOTAL_SLOTS; slot++) {
  if (!fitsUHeight(slot, uHeight)) continue;

  const bankIndex  = getBankIndex(slot);
  const phaseIndex = 0;

  const feeds = Math.ceil(server.psuCount / 2);

  const newBankLoad  = (banks[bankIndex] || 0) + ampsPerFeed * feeds;
  const newPhaseLoad = (phases[0] || 0) + ampsPerFeed * feeds;


  if (newBankLoad  > LIMITS.bank)  continue;
  if (newPhaseLoad > LIMITS.phase) continue;

  const score =
    newBankLoad  / LIMITS.bank +
    newPhaseLoad / LIMITS.phase;

  if (!best || score < best.score) {
    best = {
      slot,
      bankIndex,
      phaseIndex,
      newBank:  newBankLoad,
      newPhase: newPhaseLoad,
      ampsPerFeed,
      uHeight
    };
  }
}


  return best;
}

/* =========================================================
   INITIALIZATION
   ========================================================= */

/**
 * Entry point for the  PDU page.
 *
 * Loads the shared application layout and performs
 * the initial render of the rack, load summaries,
 * and UI bindings.
 */


window.addEventListener("DOMContentLoaded",async()=>{
  await loadLayout("apc");
  render();
  document.body.classList.add("page-loaded");
});

</script>
</body>
</html>